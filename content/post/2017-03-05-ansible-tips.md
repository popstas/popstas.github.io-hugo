+++
title = "Ansible tips"
date = "2017-03-05T20:45:00"
slug = "migrate-from-octopress-to-hugo"
image = "/"
Tags = ["ansible", "molecule", "docker", "vagrant", "blog"]
draft = true
+++

TODO: тут будет вступление

![]({{< param image >}})
<!--more-->

## Что я узнал, пока писал роли для ansible

### DebOps во всем прав
Единственный полноценный проект, который я нашел - debops. Там все очень энтерпрайзно, [страшное дерево зависимостей](https://camo.githubusercontent.com/bf2e1de3308fcd8df32ab21666c211a95ffa16f8/68747470733a2f2f6465626f70732e6f72672f696d616765732f646570656e64656e63792d67726170682e706e67), поэтому я побоялся использовать его как есть, но многие вещи я подсматриваю там.
Единственный полноценный проект, который я нашел - debops. Там все очень энтерпрайзно, [страшное дерево зависимостей](https://camo.githubusercontent.com/bf2e1de3308fcd8df32ab21666c211a95ffa16f8/68747470733a2f2f6465626f70732e6f72672f696d616765732f646570656e64656e63792d67726170682e706e67), поэтому я побоялся использовать его как есть, но многие вещи я подсматриваю там.

https://github.com/debops/debops-playbooks/blob/master/README.rst



### Нужны стандарты написания
Сначала я смотрел стиль написания у тех, у кого брал готовые роли. Потом были конфликты переменных, непонимание того, откуда пришла переменная, плохая подсветка кода. Опять выручил DebOps с готовыми [стандартами написания](https://docs.debops.org/en/latest/debops-policy/docs/code-standards-policy.html).



### Роли должны быть независимыми
Ничего хорошего нет в том, что роли могут выполниться только в определенной последовательности.

Самый главный недостаток этого: тестировать такие роли дольше, т.к. надо запустить всю последовательность.

Вместо этого лучше лишний раз прописать какой-нибудь `apt: name=python-dev state=present`, это будет немного дольше запускаться, но как показала практика, боевой запуск ролей по времени не критичен (если у вас всего несколько серверов, как у меня), а вот тестирование, когда ошибка проявляется только при запуске всего дерева ролей, проходит очень долго.

Во-вторых, если у вас роли не работают независимо, можете забыть о continous integration

В-третьих, при тестировании каждой роли с нуля на чистой машине, выясняются все их зависимости, оказыавется, что до этого одни роли зависели от других, причем это было незаметно, т.к. они выполнялись всегда в одной последовательности.



### Не надо писать свою обвязку для тестирования
Я наступил и на эти грабли. С одной стороны из-за того, что я подумал, что мне мозгов не хватит сразу освоить какой-нибудь test kitchen. С другой, я решил, что мне столько возможностей не надо, сколько они дают. В итоге получился кривой велосипед.

Сначала я создавал виртуалки вручную (через vagrant), запускал там тесты, убивал.

Потом я попробовал тестировать в docker.

Потом я написал пару bash-скриптов. Один подготавливал виртуалку или контейнер, настраивал подключение к ним по ssh, прописывал в тестовый inventory файл. Второй прогонял на них тесты, ansible-lint, идемпотентность. Естественно, никакого конфига не было, все настраивалось через env, ломалось.

Тогда я поискал готовый тестовый фреймворк и нашел molecule. Все оказалось очень просто, уже через час я научился пользоваться им на уровне своего велосипеда.



### Частичный запуск ролей нужно делать через отдельные плейбуки
Опять же, я проигнорировал точку зрения, что теги неконтролируемы.

Теги нужно проставлять к КАЖДОМУ таску, как результат мы имеем кучу копипасты и часть тасков без тегов.

https://docs.debops.org/en/latest/debops-playbooks/docs/playbook-layout.html

Здесь все не так просто: вы можете захотеть запустить часть роли, даже если она достаточно мелкая. Например, в роли viasite-ansible.server-scripts я захотел сделать безболезненное обновление на всех серверах, при этом не перезаписывая конфиг. Поэтому я добавил нужным таскам тег `upgrade` и запускаю роль с этим тегом:
```
ansible-playbook playbooks/roles/server-scripts.yml --limit prod --tags upgrade
```
Было бы удобнее, если бы можно было сделать отдельный плейбук, в котором ограничить теги из запускаемой роли, но так сделать нельзя, если в `roles` прописать `- { name: server-scripts, tags: upgrade }`, то это будет значить, что вы назначили этот тег всем входящим в роль таскам.



## Настройка подключения

### Используйте pipeling = true в ansible.cfg
Ansible при выполнении задач сначала формирует файл с командами, потом копирует его на удаленный хост, потом выполняет его. Эта настройка убирает копирование файла и передает команды прямо через ssh, что по сути в 2 раза сокращает количество операций по задачам.

У этой настройки есть ограничение: в файле `/etc/sudoers` должен быть отключен `requiretty`, у меня на Ubuntu 16.04 такого нет. Подробности в [документации](http://docs.ansible.com/ansible/intro_configuration.html#pipelining).

Чтобы это заработало, нужно добавить в файл `ansible.cfg` строчку в секцию `[ssh_connection]`:
```
[ssh_connection]
pipeling = true
```

На настраиваемую машину можно пробрасывать свои ssh ключи. То есть, выполняя на удаленной машине `git clone`, `rsync` и прочие работающие поверх ssh штуки, удаленную машину будут пускать на сервера и репозитории, к которой есть доступ у вашей локальной машины. Магия!
```
ssh_args = -o ForwardAgent=yes
```
Да, чтобы магия сработала, у вас должен быть запущен ssh-agent.Это можно сделать
[так](http://unix.stackexchange.com/questions/90853/how-can-i-run-ssh-add-automatically-without-password-prompt):
```
eval $(ssh-agent)
if [ -z "$SSH_AUTH_SOCK" ] ; then
  eval `ssh-agent -s`
  ssh-add
fi
```

Перед тем, как использовать эту фичу, прочитайте [мнение о вреде ForwardAgent](https://heipei.github.io/2015/02/26/SSH-Agent-Forwarding-considered-harmful/).

Также, имейте в виду, что агент пробрасывается только на `ansible_user_id`, то есть, если в таске написано `become_user: other_user`,
он ваши ключи не увидит.



## Проверяйте то, что вы собираетесь запустить
- `--list-hosts` - выведет список хостов с учетом всех лимитов.
- `--check` - dry run, прогонит роли как будто по-настоящему, но по факту ничего менять не будет. На самом деле, он показывает не 100% реальных изменений,
  так как одни изменения могут зависеть от других и пока один таск не будет по-настоящему отработан, другой может быть пропущен
- `--diff` - показывает диффы изменений в конфигах, очень полезный ключик, я всегда добавляю его, когда не знаю точно, что будет изменено



## Проблемы в сценариях, которые я сразу понял как решать

### Зависание rsync или другой ssh команды из-за неправильной авторизации
Такое может случиться, если вы используете command: rsync вместо модуля `syncronize` (на что есть причины).

Если хост, к которому вы подключаетесь, не доверен или ваш ключ не подходит, или вы забыли включить ssh-agent,
ssh вас об этом предупредит, но вы этого не увидите, т.к. ansible не показывает вывод программ. В результате у меня были таски,
которые могли подвиснуть навсегда, причем нельзя определить по работе ansible, то ли там на вопрос просят ответить, то ли там 5 Гб синхронизируется.

Это решается передачей опции `-o BatchMode=yes` в команду, можно реализовать это в виде отдельного таска:
``` yaml
- name: Check ssh connection
  command: ssh -o BatchMode=yes "{{ user }}@{{ host }}" exit
  changed_when: false
```

Либо передать прямо в rsync:
``` yaml
- name: Sync file
  command: rsync -e "ssh -o BatchMode=yes" "{{ user }}@{{ host }}:{{ path }}" "{{ dest }}
```

Мне больше первый вариант нравится, т.к. сразу понятно, что проблема в подключении.




## Итог
Я вижу, куда все идет: debops оказываются во всем правы, в итоге я пишу большой велосипед, который будет его жалким подобием.

Надеюсь, что я все-таки выбрал правильный путь.
